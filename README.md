Streamux
========

A minimalist, multiplexing, asynchronous, bi-directional messaging and streaming protocol.

This is a protocol between peers. Each side may act in both a client and a server role, sending messages and replying to messages.

This protocol functions as a low level multiplexing, asynchronous, interruptible message chunking layer. It is expected that a messaging protocol will be layered on top of it. Even something primitive like using JSON objects as messages would work fine.


## Operation

* Open connection
* Peers each send an initiator message
* Peers send and receive messages and replies
* Close connection


## Initiator message

Before sending any other messages, a peer must send an initiator message:

| Octet 1 | Octet 2          | Octet 3      | Octet 4                    |
| ------- | ---------------- | ------------ | -------------------------- |
| Version | Length Bit Count | ID Bit Count | Timeout (10ths of seconds) |

The initiator message is not acknowledged by the other peer. Each peer sends its own initiator message.

Version is currently 1.

The total number of bits must add up to either 14 or 30. Neither bit count may be 0. A low length field bit count increases the marginal costs of the header. A low ID bit count limits the maximum number of simultaneous outstanding operations. Which settings are optimal will depend on your use case.

If total bits (length bits + ID bits) is 14, message headers will be 2 octets long. If total bits is 30, message headers will be 4 octets long.

Timeout specifies how long a peer intends wait for a reply in 10ths of seconds when acting as a client. If an operation takes longer than the timeout, the server peer may elect to preemptively cancel the operation. If timeout is 0, it means that the timeout is unspecified, and the server must not preemptively cancel any operations. Once the first chunk of a reply has been queued for sending, the operation is considered complete, and may no longer be preemptively canceled by the server.

Note: The client is not required to adhere to the timeout it specifies; it may cancel any message at any time, for any reason.

Each peer may specify its own bit counts and timeout. The other peer must adhere to these constraints when receiving and replying to messages, but may specify its own (possibly different) parameters for messages it sends.

If a peer detects an error in the initiator message, it must close the connection, or discard all future messages if the connection cannot be closed.


## Regular Messages

### Layout

| Section | Octets   |
| ------- | -------- |
| Header  | 2 or 4   |
| Data    | variable |


### Header

| Field       | Bits      |
| ----------- | --------- |
| Termination |         1 |
| Reply       |         1 |
| Length      |  variable |
| ID          |  variable |

#### Bit Layout

The header is sent over the wire as a little endian 16 or 32 bit unsigned integer.

For example, a 17/13 header would be conceptually viewed as:

    trllllllllllllllllliiiiiiiiiiiii

The header would actually be transmitted in little endian format:

    iiiiiiii llliiiii llllllll trllllll


### Fields

#### Termination

The termination bit indicates that this is the final chunk for this message ID. For a large message that spans multiple chunks, you would set this to 0 for all but the last chunk.

#### Reply

The reply bit is used to reply to a message sent by a peer. When set, the ID field refers to the ID of the original message sent by the peer, and the reply must use the same bit layout for length and ID as the other peer specified in its initiator message.

#### Length

The length field refers to the number of octets in the data portion of this chunk (i.e. the header portion does not count towards the length).

#### ID

The ID field is a unique number that is generated by the sender to differentiate the current message from other messages the sender has sent in the past. The sender must not use IDs that are currently in-flight (IDs that have been sent to the peer but have not yet received a reply, or have been canceled but not yet acked).


## Special Messages

A length of 0 confers special meaning to the message, depending on the reply and termination fields:

| Length | Reply | Termination | Meaning     |
| ------ | ----- | ----------- | ----------- |
|    0   |   0   |       0     | Cancel      |
|    0   |   1   |       0     | Cancel Ack  |
|    0   |   0   |       1     | Keep Alive  |
|    0   |   1   |       1     | Empty Reply |

### Cancel

The cancel message cancels an operation in progress. The ID field specifies the operation to cancel. After sending a cancel message, the ID is locked (cannot be used, and all replies to that ID are discarded) until a Cancel Ack message for that ID is received.

### Cancel Ack

Sent in response to a cancel request. All queued replies to that ID are removed, and the operation is canceled. Once the cancel is completed, the server sends a Cancel Ack. If the operation doesn't exist (possibly because it had already completed), the server still sends a Cancel Ack.

### Keep Alive

Each side keeps track of how long it's been idle (no messages in the send queue). After a threshold idle time, the peer should send a keep alive message using the next free ID. Keep alive messages are not acknowledged (the server must not reply to it).

### Empty Reply

Can be sent in response to a message, indicating successful completion but no other data to report.


## Sending Messages

Messages are sent in chunks. A multi-chunk message has its termination bit cleared to 0 for all but the last chunk. Single chunk messages always have the termination bit set.

The message ID is scoped to the sender. If both sides of the channel send a message with the same ID, they are considered different messages, and don't interfere with each other. A peer replies to a message by using the same message ID as it received from the sender, and setting the reply bit.

### Flow

The message send and receive flow is as follows:

* Sender creates message ID 5 (with the reply bit cleared).
* Sender sends message ID 5 to the receiver.
* Receiver processes message ID 5
* Receiver creates response to message ID 5 (with the reply bit set).
* Receiver sends response ID 5 to the sender.

This works in both directions. Participants are peers, and can both initiate and respond to messages.

Responses may be sent in a different order than the requests were received.


### Multiplexing

Message chunks with the same ID must be sent in-order. The message is considered complete once the termination bit is set. Note that this does not require you to send all chunks for one message before sending chunks from another message. They can be interspersed, like so:

* Message 10, chunk 0
* Message 11, chunk 0
* Message 12, chunk 0
* Message 11, chunk 1
* Message 10, chunk 1 (termination)
* Message 11, chunk 2
* Message 12, chunk 1 (termination)
* Message 11, chunk 3 (termination)

How message chunks are sized and scheduled depends on your use case.


## Timing

A message must receive a response within a reasonable time. Each peer can tell the other what their timeout expectations are in their initiator message.

If a sender has not received a response within a timeout period, it may send a cancel message to cancel the outstanding operation.


## Message Cancellation

There are times when a sender might want to cancel an operation-in-progress. It may do so with a cancel message, citing the ID of the message to be canceled.

Once a cancel has been issued, the ID of that message is locked. A locked message cannot be used as a message ID, and all replies to that message ID are discarded. Once a Cancel Ack reply is received, the message ID is unlocked and may be used again.

Example:

* Sender sends message ID 19
* Sender times out
* Sender sends cancel ID 19
* Receiver sends reply ID 19, which is discarded by the sender
* Receiver sends cancel ack ID 19

If a Cancel Ack is not received, it means that either the server is lagged, or is operating incorrectly.


## Keep Alive

If the sending channel is idle for too long (no messages to send), a peer must send keep-alive messages from time to time.

TODO: What is the optimal keepalive timeout? Smaller than the message timeout?

TODO: Figure out how to more accurately distinguish lag from a stuck process.

If a peer has not received any messages within the timeout period, it may assume that the sender is lagged. Timeouts should be chosen to compensate for the expected lag.


## Complex or Long Operations

This protocol expects replies to be received in a timely manner. Operations at this level are not expected to be very complex. If an operation will take a long time to complete or has other complications, it's advisable to implement a callback mechanism:

| Side   | Role   | Operation                             |
| ------ | ------ | ------------------------------------- |
| Peer A | Client | Message: Request + callback token     |
| Peer B | Server | Reply: Callback successfully queued   |

Peer B takes time processing the request, then, acting in a "client" role:

| Side   | Role   | Operation                             |
| ------ | ------ | ------------------------------------- |
| Peer B | Client | Message: Result data + callback token |
| Peer A | Server | Reply: Callback acknowledged          |

The actual implementation of such a callback mechanism would be at a higher level than this protocol, and is thus beyond the scope of this document.


## Spurious Messages

If a spurious (unexpected) message or reply is received, the peer should discard the message and ignore it. Spurious messages include:

* Reply to a canceled message.
* Cancel message for an operation not in progress.

These situations can arise when the transmission medium is lagged or interrupted. A reply to a message may have already been en-route at the time of cancellation, or the operation may have completed before the cancel message arrived.

The following are likely error conditions:

* Reply to a nonexistent message.
* Cancel Ack for a message that wasn't canceled.

In the error case, the peer may elect to report an error (outside of the scope of this protocol) or end the connection, depending on your use case.


Version History
---------------

 * April 10, 2019: Preview Version 1



License
-------

Copyright (c) 2019 Karl Stenerud. All rights reserved.

Distributed under the Creative Commons Attribution License: https://creativecommons.org/licenses/by/4.0/legalcode
License deed: https://creativecommons.org/licenses/by/4.0/
